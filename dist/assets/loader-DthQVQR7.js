import{r as c,a as u,b as p}from"./index-CpYWmskZ.js";let i=!1,n=null;function f(o){const r=[];return o?(o.version||r.push('Campo "version" obrigatório não encontrado'),(!o.nodes||!Array.isArray(o.nodes))&&r.push('Campo "nodes" deve ser um array'),o.categories&&!Array.isArray(o.categories)&&r.push('Campo "categories" deve ser um array'),o.nodes&&o.nodes.forEach((e,s)=>{e.type||r.push(`Node no índice ${s} não possui campo "type"`),e.label||r.push(`Node "${e.type||s}" não possui campo "label"`),e.method||r.push(`Node "${e.type||s}" não possui campo "method"`),e.category||r.push(`Node "${e.type||s}" não possui campo "category"`)}),{valid:r.length===0,errors:r}):(r.push("Catálogo está vazio ou inválido"),{valid:!1,errors:r})}async function l(o="/config/nodes.json"){if(i)return n;try{const e=await fetch(`${o}`);if(!e.ok)throw new Error(`Erro ao carregar catálogo: ${e.status} ${e.statusText}`);const s=await e.json(),a=f(s);if(!a.valid)throw new Error(`Catálogo inválido: ${a.errors.join(", ")}`);return s.categories&&s.categories.forEach(t=>{u(t.id,t)}),s.nodes.forEach(t=>{p(t.type,t)}),i=!0,n=s,s}catch(r){throw r}}async function d(){try{return{success:!0,catalog:await l(),stats:c.getStats()}}catch(o){return{success:!1,error:o.message}}}export{d as initializeEngine,l as loadNodeCatalog};
