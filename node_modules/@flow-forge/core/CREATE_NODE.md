# üéØ Como Criar um Novo Node

Guia completo para criar nodes no FlowForge Core.

## üìã √çndice

1. [Vis√£o Geral](#vis√£o-geral)
2. [Passo 1: Criar Method](#passo-1-criar-method)
3. [Passo 2: Adicionar em nodes.json](#passo-2-adicionar-em-nodesjson)
4. [Passo 3: Atualizar Mappings (se necess√°rio)](#passo-3-atualizar-mappings-se-necess√°rio)
5. [Exemplos Completos](#exemplos-completos)

## Vis√£o Geral

Criar um novo node envolve 3 arquivos (todos no Core):

```
packages/core/src/
‚îú‚îÄ‚îÄ methods/[categoria]/[nome].js  ‚Üê 1. Implementa√ß√£o
‚îú‚îÄ‚îÄ config/nodes.json              ‚Üê 2. Defini√ß√£o
‚îî‚îÄ‚îÄ config/mappings.js             ‚Üê 3. Mappings (opcional)
```

## Passo 1: Criar Method

### 1.1 Escolher Categoria

Escolha a categoria apropriada:

- `comparison/` - Compara√ß√µes (>, <, ==, etc.)
- `connectors/` - Conectores externos (APIs, Sheets, etc.)
- `constants/` - Valores constantes
- `conversion/` - Convers√£o de tipos
- `io/` - Input/Output
- `iteration/` - Loops (forEach, while)
- `logic/` - L√≥gica condicional
- `organization/` - Markers visuais
- `processors/` - Processadores (arrays, objects, math, etc.)
- `storage/` - Vari√°veis e storage
- `string/` - Opera√ß√µes com strings

### 1.2 Criar Arquivo

Crie `packages/core/src/methods/[categoria]/[nome].js`

**Template b√°sico:**

```javascript
/**
 * [Nome do Node]
 * [Descri√ß√£o breve do que ele faz]
 */

import { unwrapData } from '../../utils/dataUtils.js'

/**
 * [Descri√ß√£o da fun√ß√£o]
 * @param {Object} params
 * @param {Object} params.nodeData - Configura√ß√£o do node
 * @param {Object} params.inputs - Inputs recebidos
 * @param {Object} params.context - Contexto de execu√ß√£o
 * @returns {*} Resultado da execu√ß√£o
 */
export function execute({ nodeData, inputs, context }) {
  // 1. Unwrap inputs
  const inputValue = unwrapData(inputs.inputName)

  // 2. Processar
  const result = inputValue.toUpperCase() // exemplo

  // 3. Retornar resultado
  return result
}

/**
 * Valida configura√ß√£o do node (opcional mas recomendado)
 * @param {Object} nodeData - Configura√ß√£o do node
 * @returns {Object} { valid: boolean, errors: Array }
 */
export function validate(nodeData) {
  const errors = []

  // Validar campos obrigat√≥rios
  if (!nodeData.config?.field) {
    errors.push('Campo "field" √© obrigat√≥rio')
  }

  return {
    valid: errors.length === 0,
    errors
  }
}
```

### 1.3 Patterns Comuns

**Node com m√∫ltiplas fun√ß√µes:**

```javascript
export function add({ inputs }) {
  const a = unwrapData(inputs.a)
  const b = unwrapData(inputs.b)
  return a + b
}

export function subtract({ inputs }) {
  const a = unwrapData(inputs.a)
  const b = unwrapData(inputs.b)
  return a - b
}

export function validate(nodeData) {
  return { valid: true, errors: [] }
}
```

**Node com configura√ß√£o:**

```javascript
export function execute({ nodeData, inputs, context }) {
  const inputArray = unwrapData(inputs.array)
  const sortOrder = nodeData.config?.sortOrder || 'asc' // Ler config

  const sorted = [...inputArray].sort((a, b) => {
    return sortOrder === 'asc' ? a - b : b - a
  })

  return sorted
}
```

**Node ass√≠ncrono (connector):**

```javascript
export async function execute({ nodeData, inputs, context }) {
  const url = nodeData.config?.url
  const data = unwrapData(inputs.data)

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    return await response.json()
  } catch (error) {
    throw new Error(`Erro ao chamar API: ${error.message}`)
  }
}
```

## Passo 2: Adicionar em nodes.json

### 2.1 Adicionar Categoria (se necess√°rio)

Se for uma nova categoria, adicione em `categories`:

```json
{
  "categories": [
    {
      "id": "minha-categoria",
      "name": "Minha Categoria",
      "icon": "üéØ"
    }
  ]
}
```

### 2.2 Adicionar Node

Adicione em `nodes`:

```json
{
  "nodes": [
    {
      "type": "meu-node",
      "category": "processors",
      "name": "Meu Node",
      "description": "Descri√ß√£o do que o node faz",
      "icon": "‚ú®",
      "color": "#4CAF50",
      "functions": ["execute"],
      "inputs": [
        {
          "id": "inputName",
          "label": "Input Label",
          "type": "string",
          "required": true,
          "description": "Descri√ß√£o do input"
        }
      ],
      "outputs": [
        {
          "id": "output",
          "label": "Output",
          "type": "string",
          "description": "Descri√ß√£o do output"
        }
      ],
      "config": {
        "fields": [
          {
            "name": "field",
            "label": "Campo",
            "type": "text",
            "required": true,
            "default": "",
            "placeholder": "Digite algo...",
            "description": "Descri√ß√£o do campo"
          }
        ]
      },
      "autoExecute": {
        "on": ["config-change", "input-change"],
        "triggers": ["inputName"]
      }
    }
  ]
}
```

### 2.3 Tipos de Campos de Configura√ß√£o

```json
{
  "type": "text",          // Input de texto
  "type": "textarea",      // Textarea
  "type": "number",        // Input num√©rico
  "type": "select",        // Dropdown
  "options": [...],
  "type": "checkbox",      // Checkbox
  "type": "radio",         // Radio buttons
  "type": "date",          // Date picker
  "type": "color",         // Color picker
  "type": "file"           // File upload
}
```

### 2.4 Tipos de Handles (inputs/outputs)

Tipos dispon√≠veis:

- `any` - Qualquer tipo
- `string` - String
- `number` - N√∫mero
- `boolean` - Booleano
- `object` - Objeto
- `array` - Array
- `date` - Data
- `null` - Null
- `function` - Fun√ß√£o

### 2.5 Auto-Execu√ß√£o

Configure quando o node deve auto-executar:

```json
{
  "autoExecute": {
    "on": ["config-change", "input-change", "create"],
    "triggers": ["input1", "input2"]
  }
}
```

Op√ß√µes:
- `config-change` - Quando configura√ß√£o muda
- `input-change` - Quando input muda
- `create` - Quando node √© criado
- `connection` - Quando conex√£o √© feita

## Passo 3: Atualizar Mappings (se necess√°rio)

Se o node for um **connector** que comunica com API externa, adicione mappings.

### 3.1 FRONTEND_TO_CANONICAL

Mapeia campos do frontend para formato canonical:

```javascript
export const FRONTEND_TO_CANONICAL = {
  meu_connector: {
    // Frontend ‚Üí Canonical
    urlField: 'url',
    tokenField: 'token',
    dataField: 'data'
  }
}
```

### 3.2 CANONICAL_TO_SERVICE

Mapeia formato canonical para o que a API externa espera:

```javascript
export const CANONICAL_TO_SERVICE = {
  meu_connector: {
    // Canonical ‚Üí Service
    url: 'endpoint',
    token: 'apiKey',
    data: 'payload'
  }
}
```

### 3.3 SOURCE_TYPE_MAPPINGS

Mapeia nome do tipo para API:

```javascript
export const SOURCE_TYPE_MAPPINGS = {
  toApi: {
    'meu_connector': 'my_connector'
  },
  fromApi: {
    'my_connector': 'meu_connector'
  }
}
```

## Exemplos Completos

### Exemplo 1: Node Simples (String Uppercase)

**1. Method:** `packages/core/src/methods/string/uppercase.js`

```javascript
import { unwrapData } from '../../utils/dataUtils.js'

/**
 * Converte string para mai√∫sculas
 */
export function execute({ inputs }) {
  const text = unwrapData(inputs.text)

  if (typeof text !== 'string') {
    throw new Error('Input deve ser uma string')
  }

  return text.toUpperCase()
}

export function validate(nodeData) {
  return { valid: true, errors: [] }
}
```

**2. nodes.json:**

```json
{
  "type": "uppercase",
  "category": "string",
  "name": "Uppercase",
  "description": "Converte texto para mai√∫sculas",
  "icon": "üî§",
  "color": "#2196F3",
  "functions": ["execute"],
  "inputs": [
    {
      "id": "text",
      "label": "Texto",
      "type": "string",
      "required": true
    }
  ],
  "outputs": [
    {
      "id": "output",
      "label": "Resultado",
      "type": "string"
    }
  ],
  "autoExecute": {
    "on": ["input-change"],
    "triggers": ["text"]
  }
}
```

### Exemplo 2: Node com M√∫ltiplas Fun√ß√µes (Math)

**1. Method:** `packages/core/src/methods/processors/math.js`

```javascript
import { unwrapData } from '../../utils/dataUtils.js'

function extractNumericValue(input) {
  const unwrapped = unwrapData(input)
  const value = parseFloat(unwrapped)

  if (isNaN(value)) {
    throw new Error(`Valor n√£o √© um n√∫mero v√°lido: ${unwrapped}`)
  }

  return value
}

export function add({ inputs }) {
  const a = extractNumericValue(inputs.a)
  const b = extractNumericValue(inputs.b)
  return a + b
}

export function subtract({ inputs }) {
  const a = extractNumericValue(inputs.a)
  const b = extractNumericValue(inputs.b)
  return a - b
}

export function multiply({ inputs }) {
  const a = extractNumericValue(inputs.a)
  const b = extractNumericValue(inputs.b)
  return a * b
}

export function divide({ inputs }) {
  const a = extractNumericValue(inputs.a)
  const b = extractNumericValue(inputs.b)

  if (b === 0) {
    throw new Error('Divis√£o por zero n√£o permitida')
  }

  return a / b
}

export function validate(nodeData) {
  return { valid: true, errors: [] }
}
```

**2. nodes.json:**

```json
{
  "type": "math",
  "category": "processors",
  "name": "Math",
  "description": "Opera√ß√µes matem√°ticas b√°sicas",
  "icon": "‚ûï",
  "color": "#FF9800",
  "functions": ["add", "subtract", "multiply", "divide"],
  "inputs": [
    {
      "id": "a",
      "label": "A",
      "type": "number",
      "required": true
    },
    {
      "id": "b",
      "label": "B",
      "type": "number",
      "required": true
    }
  ],
  "outputs": [
    {
      "id": "result",
      "label": "Resultado",
      "type": "number"
    }
  ],
  "autoExecute": {
    "on": ["input-change", "config-change"],
    "triggers": ["a", "b"]
  }
}
```

### Exemplo 3: Node com Configura√ß√£o (Array Filter)

**1. Method:** `packages/core/src/methods/processors/arrayFilter.js`

```javascript
import { unwrapData } from '../../utils/dataUtils.js'

export function execute({ nodeData, inputs }) {
  const array = unwrapData(inputs.array)
  const filterType = nodeData.config?.filterType || 'greater'
  const threshold = nodeData.config?.threshold || 0

  if (!Array.isArray(array)) {
    throw new Error('Input deve ser um array')
  }

  const filtered = array.filter(item => {
    const value = typeof item === 'object' ? item.value : item

    switch (filterType) {
      case 'greater':
        return value > threshold
      case 'less':
        return value < threshold
      case 'equal':
        return value === threshold
      default:
        return true
    }
  })

  return filtered
}

export function validate(nodeData) {
  const errors = []

  if (!nodeData.config?.filterType) {
    errors.push('Tipo de filtro √© obrigat√≥rio')
  }

  return {
    valid: errors.length === 0,
    errors
  }
}
```

**2. nodes.json:**

```json
{
  "type": "arrayFilter",
  "category": "processors",
  "name": "Array Filter",
  "description": "Filtra elementos de um array",
  "icon": "üîç",
  "color": "#9C27B0",
  "functions": ["execute"],
  "inputs": [
    {
      "id": "array",
      "label": "Array",
      "type": "array",
      "required": true
    }
  ],
  "outputs": [
    {
      "id": "output",
      "label": "Filtrado",
      "type": "array"
    }
  ],
  "config": {
    "fields": [
      {
        "name": "filterType",
        "label": "Tipo de Filtro",
        "type": "select",
        "required": true,
        "default": "greater",
        "options": [
          { "value": "greater", "label": "Maior que" },
          { "value": "less", "label": "Menor que" },
          { "value": "equal", "label": "Igual a" }
        ]
      },
      {
        "name": "threshold",
        "label": "Valor de Refer√™ncia",
        "type": "number",
        "required": true,
        "default": 0
      }
    ]
  },
  "autoExecute": {
    "on": ["input-change", "config-change"],
    "triggers": ["array"]
  }
}
```

## ‚úÖ Checklist

Antes de considerar o node pronto:

- [ ] Method criado em `methods/[categoria]/[nome].js`
- [ ] Exporta fun√ß√£o(√µes) nomeada(s)
- [ ] Usa `unwrapData()` para processar inputs
- [ ] Implementa `validate()` (opcional mas recomendado)
- [ ] Trata erros apropriadamente
- [ ] Defini√ß√£o adicionada em `config/nodes.json`
- [ ] Categoria existe em `categories`
- [ ] `type` √∫nico e descritivo
- [ ] Inputs e outputs definidos com tipos corretos
- [ ] Config fields definidos (se necess√°rio)
- [ ] AutoExecute configurado apropriadamente
- [ ] Mappings atualizados (se for connector)
- [ ] Testado via Frontend/API

## üéâ Pronto!

Ap√≥s seguir estes passos, seu node estar√° dispon√≠vel automaticamente em:

- ‚úÖ Frontend (via GET /api/nodes)
- ‚úÖ API (via dynamic import do Core)
- ‚úÖ Qualquer outro package que use o Core

**Tudo em um lugar!** üöÄ
